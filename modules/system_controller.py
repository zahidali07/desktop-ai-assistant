"#!/usr/bin/env python3\n\"\"\"\nSystem Controller Module for Desktop AI Assistant\n\nThis module provides comprehensive system automation and control capabilities\nincluding application management, file operations, system settings, and\ndesktop automation tasks.\n\nFeatures:\n- Application launching and control\n- File and directory operations\n- System settings management\n- Window management\n- Keyboard and mouse automation\n- Process management\n- Network operations\n- System information retrieval\n\nAuthor: Desktop AI Assistant Project\nVersion: 1.0.0\n\"\"\"\n\nimport asyncio\nimport logging\nimport os\nimport platform\nimport subprocess\nimport time\nimport webbrowser\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any, Tuple\nimport json\nimport shutil\n\ntry:\n    import psutil\n    import pyautogui\n    from pynput import keyboard, mouse\n    from pynput.keyboard import Key, Listener as KeyboardListener\n    from pynput.mouse import Listener as MouseListener\nexcept ImportError as e:\n    logging.error(f\"Required automation libraries not installed: {e}\")\n    logging.error(\"Please install: pip install psutil pyautogui pynput\")\n\n# Platform-specific imports\nif platform.system() == \"Windows\":\n    try:\n        import win32api\n        import win32gui\n        import win32con\n        import win32process\n    except ImportError:\n        logging.warning(\"Windows-specific libraries not available. Install: pip install pywin32\")\nelif platform.system() == \"Darwin\":\n    try:\n        import AppKit\n    except ImportError:\n        logging.warning(\"macOS-specific libraries not available. Install: pip install pyobjc\")\nelif platform.system() == \"Linux\":\n    try:\n        import Xlib\n        from Xlib import display\n    except ImportError:\n        logging.warning(\"Linux-specific libraries not available. Install: pip install python-xlib\")\n\nlogger = logging.getLogger(__name__)\n\n\nclass SystemController:\n    \"\"\"\n    System automation and control handler for the Desktop AI Assistant\n    \"\"\"\n    \n    def __init__(self, config):\n        self.config = config\n        self.platform = platform.system()\n        self.running_processes = {}\n        self.automation_enabled = True\n        \n        # Configure pyautogui safety\n        pyautogui.FAILSAFE = True\n        pyautogui.PAUSE = 0.1\n        \n        # Initialize platform-specific components\n        self._initialize_platform_specific()\n        \n        logger.info(f\"System controller initialized for {self.platform}\")\n    \n    def _initialize_platform_specific(self):\n        \"\"\"Initialize platform-specific functionality\"\"\"\n        if self.platform == \"Windows\":\n            self._init_windows()\n        elif self.platform == \"Darwin\":\n            self._init_macos()\n        elif self.platform == \"Linux\":\n            self._init_linux()\n    \n    def _init_windows(self):\n        \"\"\"Initialize Windows-specific functionality\"\"\"\n        try:\n            self.win32_available = True\n            logger.info(\"Windows automation libraries loaded\")\n        except:\n            self.win32_available = False\n            logger.warning(\"Windows automation libraries not available\")\n    \n    def _init_macos(self):\n        \"\"\"Initialize macOS-specific functionality\"\"\"\n        try:\n            self.appkit_available = True\n            logger.info(\"macOS automation libraries loaded\")\n        except:\n            self.appkit_available = False\n            logger.warning(\"macOS automation libraries not available\")\n    \n    def _init_linux(self):\n        \"\"\"Initialize Linux-specific functionality\"\"\"\n        try:\n            self.xlib_available = True\n            logger.info(\"Linux automation libraries loaded\")\n        except:\n            self.xlib_available = False\n            logger.warning(\"Linux automation libraries not available\")\n    \n    # Application Management\n    async def launch_application(self, app_name: str, args: List[str] = None) -> bool:\n        \"\"\"Launch an application by name or path\"\"\"\n        try:\n            logger.info(f\"Launching application: {app_name}\")\n            \n            # Common application mappings\n            app_mappings = self._get_app_mappings()\n            \n            # Check if it's a mapped application\n            if app_name.lower() in app_mappings:\n                app_path = app_mappings[app_name.lower()]\n            else:\n                app_path = app_name\n            \n            # Prepare command\n            cmd = [app_path]\n            if args:\n                cmd.extend(args)\n            \n            # Launch the application\n            process = await asyncio.create_subprocess_exec(\n                *cmd,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE\n            )\n            \n            # Store process reference\n            self.running_processes[app_name] = process\n            \n            logger.info(f\"Successfully launched {app_name} (PID: {process.pid})\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to launch {app_name}: {e}\")\n            return False\n    \n    def _get_app_mappings(self) -> Dict[str, str]:\n        \"\"\"Get platform-specific application mappings\"\"\"\n        if self.platform == \"Windows\":\n            return {\n                \"notepad\": \"notepad.exe\",\n                \"calculator\": \"calc.exe\",\n                \"chrome\": \"chrome.exe\",\n                \"firefox\": \"firefox.exe\",\n                \"explorer\": \"explorer.exe\",\n                \"cmd\": \"cmd.exe\",\n                \"powershell\": \"powershell.exe\",\n                \"vscode\": \"code.exe\",\n                \"word\": \"winword.exe\",\n                \"excel\": \"excel.exe\",\n                \"outlook\": \"outlook.exe\"\n            }\n        elif self.platform == \"Darwin\":\n            return {\n                \"safari\": \"/Applications/Safari.app\",\n                \"chrome\": \"/Applications/Google Chrome.app\",\n                \"firefox\": \"/Applications/Firefox.app\",\n                \"finder\": \"/System/Library/CoreServices/Finder.app\",\n                \"terminal\": \"/Applications/Utilities/Terminal.app\",\n                \"vscode\": \"/Applications/Visual Studio Code.app\",\n                \"textedit\": \"/Applications/TextEdit.app\",\n                \"calculator\": \"/Applications/Calculator.app\"\n            }\n        else:  # Linux\n            return {\n                \"firefox\": \"firefox\",\n                \"chrome\": \"google-chrome\",\n                \"terminal\": \"gnome-terminal\",\n                \"nautilus\": \"nautilus\",\n                \"gedit\": \"gedit\",\n                \"calculator\": \"gnome-calculator\",\n                \"vscode\": \"code\"\n            }\n    \n    async def close_application(self, app_name: str) -> bool:\n        \"\"\"Close an application by name\"\"\"\n        try:\n            logger.info(f\"Closing application: {app_name}\")\n            \n            # Try to close from running processes first\n            if app_name in self.running_processes:\n                process = self.running_processes[app_name]\n                process.terminate()\n                await process.wait()\n                del self.running_processes[app_name]\n                logger.info(f\"Closed {app_name} from running processes\")\n                return True\n            \n            # Find and close by process name\n            for proc in psutil.process_iter(['pid', 'name']):\n                if app_name.lower() in proc.info['name'].lower():\n                    proc.terminate()\n                    logger.info(f\"Terminated process {proc.info['name']} (PID: {proc.info['pid']})\")\n                    return True\n            \n            logger.warning(f\"Application {app_name} not found in running processes\")\n            return False\n            \n        except Exception as e:\n            logger.error(f\"Failed to close {app_name}: {e}\")\n            return False\n    \n    def get_running_applications(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of running applications\"\"\"\n        try:\n            apps = []\n            for proc in psutil.process_iter(['pid', 'name', 'memory_info', 'cpu_percent']):\n                try:\n                    apps.append({\n                        'pid': proc.info['pid'],\n                        'name': proc.info['name'],\n                        'memory_mb': proc.info['memory_info'].rss / 1024 / 1024,\n                        'cpu_percent': proc.info['cpu_percent']\n                    })\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\n                    continue\n            \n            return sorted(apps, key=lambda x: x['memory_mb'], reverse=True)\n            \n        except Exception as e:\n            logger.error(f\"Failed to get running applications: {e}\")\n            return []\n    \n    # File Operations\n    async def open_file(self, file_path: str) -> bool:\n        \"\"\"Open a file with the default application\"\"\"\n        try:\n            logger.info(f\"Opening file: {file_path}\")\n            \n            if self.platform == \"Windows\":\n                os.startfile(file_path)\n            elif self.platform == \"Darwin\":\n                subprocess.run([\"open\", file_path])\n            else:  # Linux\n                subprocess.run([\"xdg-open\", file_path])\n            \n            logger.info(f\"Successfully opened {file_path}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to open file {file_path}: {e}\")\n            return False\n    \n    async def create_file(self, file_path: str, content: str = \"\") -> bool:\n        \"\"\"Create a new file with optional content\"\"\"\n        try:\n            logger.info(f\"Creating file: {file_path}\")\n            \n            path = Path(file_path)\n            path.parent.mkdir(parents=True, exist_ok=True)\n            \n            with open(path, 'w', encoding='utf-8') as f:\n                f.write(content)\n            \n            logger.info(f\"Successfully created {file_path}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to create file {file_path}: {e}\")\n            return False\n    \n    async def delete_file(self, file_path: str) -> bool:\n        \"\"\"Delete a file or directory\"\"\"\n        try:\n            logger.info(f\"Deleting: {file_path}\")\n            \n            path = Path(file_path)\n            if path.is_file():\n                path.unlink()\n            elif path.is_dir():\n                shutil.rmtree(path)\n            else:\n                logger.warning(f\"Path {file_path} does not exist\")\n                return False\n            \n            logger.info(f\"Successfully deleted {file_path}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to delete {file_path}: {e}\")\n            return False\n    \n    async def copy_file(self, source: str, destination: str) -> bool:\n        \"\"\"Copy a file or directory\"\"\"\n        try:\n            logger.info(f\"Copying {source} to {destination}\")\n            \n            source_path = Path(source)\n            dest_path = Path(destination)\n            \n            if source_path.is_file():\n                shutil.copy2(source, destination)\n            elif source_path.is_dir():\n                shutil.copytree(source, destination)\n            else:\n                logger.error(f\"Source {source} does not exist\")\n                return False\n            \n            logger.info(f\"Successfully copied {source} to {destination}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to copy {source} to {destination}: {e}\")\n            return False\n    \n    # System Operations\n    async def execute_command(self, command: str, shell: bool = True) -> Tuple[bool, str, str]:\n        \"\"\"Execute a system command\"\"\"\n        try:\n            logger.info(f\"Executing command: {command}\")\n            \n            if shell:\n                process = await asyncio.create_subprocess_shell(\n                    command,\n                    stdout=asyncio.subprocess.PIPE,\n                    stderr=asyncio.subprocess.PIPE\n                )\n            else:\n                cmd_parts = command.split()\n                process = await asyncio.create_subprocess_exec(\n                    *cmd_parts,\n                    stdout=asyncio.subprocess.PIPE,\n                    stderr=asyncio.subprocess.PIPE\n                )\n            \n            stdout, stderr = await process.communicate()\n            \n            stdout_str = stdout.decode('utf-8') if stdout else \"\"\n            stderr_str = stderr.decode('utf-8') if stderr else \"\"\n            \n            success = process.returncode == 0\n            \n            if success:\n                logger.info(f\"Command executed successfully: {command}\")\n            else:\n                logger.error(f\"Command failed: {command} - {stderr_str}\")\n            \n            return success, stdout_str, stderr_str\n            \n        except Exception as e:\n            logger.error(f\"Failed to execute command {command}: {e}\")\n            return False, \"\", str(e)\n    \n    def get_system_info(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive system information\"\"\"\n        try:\n            info = {\n                'platform': platform.platform(),\n                'system': platform.system(),\n                'release': platform.release(),\n                'version': platform.version(),\n                'machine': platform.machine(),\n                'processor': platform.processor(),\n                'cpu_count': psutil.cpu_count(),\n                'cpu_percent': psutil.cpu_percent(interval=1),\n                'memory': {\n                    'total': psutil.virtual_memory().total,\n                    'available': psutil.virtual_memory().available,\n                    'percent': psutil.virtual_memory().percent\n                },\n                'disk': {\n                    'total': psutil.disk_usage('/').total,\n                    'free': psutil.disk_usage('/').free,\n                    'percent': psutil.disk_usage('/').percent\n                },\n                'boot_time': psutil.boot_time(),\n                'users': [user.name for user in psutil.users()]\n            }\n            \n            return info\n            \n        except Exception as e:\n            logger.error(f\"Failed to get system info: {e}\")\n            return {}\n    \n    # Window Management\n    def get_active_window(self) -> Optional[Dict[str, Any]]:\n        \"\"\"Get information about the currently active window\"\"\"\n        try:\n            if self.platform == \"Windows\" and hasattr(self, 'win32_available'):\n                hwnd = win32gui.GetForegroundWindow()\n                window_text = win32gui.GetWindowText(hwnd)\n                class_name = win32gui.GetClassName(hwnd)\n                \n                return {\n                    'title': window_text,\n                    'class': class_name,\n                    'handle': hwnd\n                }\n            \n            # For other platforms, use pyautogui\n            active_window = pyautogui.getActiveWindow()\n            if active_window:\n                return {\n                    'title': active_window.title,\n                    'left': active_window.left,\n                    'top': active_window.top,\n                    'width': active_window.width,\n                    'height': active_window.height\n                }\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Failed to get active window: {e}\")\n            return None\n    \n    def get_all_windows(self) -> List[Dict[str, Any]]:\n        \"\"\"Get information about all open windows\"\"\"\n        try:\n            windows = []\n            \n            if self.platform == \"Windows\" and hasattr(self, 'win32_available'):\n                def enum_windows_callback(hwnd, windows_list):\n                    if win32gui.IsWindowVisible(hwnd):\n                        window_text = win32gui.GetWindowText(hwnd)\n                        if window_text:\n                            windows_list.append({\n                                'title': window_text,\n                                'handle': hwnd,\n                                'class': win32gui.GetClassName(hwnd)\n                            })\n                \n                win32gui.EnumWindows(enum_windows_callback, windows)\n            else:\n                # Use pyautogui for other platforms\n                all_windows = pyautogui.getAllWindows()\n                for window in all_windows:\n                    windows.append({\n                        'title': window.title,\n                        'left': window.left,\n                        'top': window.top,\n                        'width': window.width,\n                        'height': window.height\n                    })\n            \n            return windows\n            \n        except Exception as e:\n            logger.error(f\"Failed to get all windows: {e}\")\n            return []\n    \n    # Automation Actions\n    async def click_at_position(self, x: int, y: int, button: str = 'left') -> bool:\n        \"\"\"Click at a specific screen position\"\"\"\n        try:\n            if not self.automation_enabled:\n                logger.warning(\"Automation is disabled\")\n                return False\n            \n            logger.info(f\"Clicking at position ({x}, {y}) with {button} button\")\n            \n            if button == 'left':\n                pyautogui.click(x, y)\n            elif button == 'right':\n                pyautogui.rightClick(x, y)\n            elif button == 'middle':\n                pyautogui.middleClick(x, y)\n            \n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to click at ({x}, {y}): {e}\")\n            return False\n    \n    async def type_text(self, text: str, interval: float = 0.01) -> bool:\n        \"\"\"Type text with specified interval between characters\"\"\"\n        try:\n            if not self.automation_enabled:\n                logger.warning(\"Automation is disabled\")\n                return False\n            \n            logger.info(f\"Typing text: {text[:50]}{'...' if len(text) > 50 else ''}\")\n            pyautogui.typewrite(text, interval=interval)\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to type text: {e}\")\n            return False\n    \n    async def press_key(self, key: str) -> bool:\n        \"\"\"Press a keyboard key\"\"\"\n        try:\n            if not self.automation_enabled:\n                logger.warning(\"Automation is disabled\")\n                return False\n            \n            logger.info(f\"Pressing key: {key}\")\n            pyautogui.press(key)\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to press key {key}: {e}\")\n            return False\n    \n    async def key_combination(self, keys: List[str]) -> bool:\n        \"\"\"Press a combination of keys\"\"\"\n        try:\n            if not self.automation_enabled:\n                logger.warning(\"Automation is disabled\")\n                return False\n            \n            logger.info(f\"Pressing key combination: {'+'.join(keys)}\")\n            pyautogui.hotkey(*keys)\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to press key combination {keys}: {e}\")\n            return False\n    \n    # Network Operations\n    async def open_url(self, url: str) -> bool:\n        \"\"\"Open a URL in the default browser\"\"\"\n        try:\n            logger.info(f\"Opening URL: {url}\")\n            webbrowser.open(url)\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to open URL {url}: {e}\")\n            return False\n    \n    def get_network_info(self) -> Dict[str, Any]:\n        \"\"\"Get network interface information\"\"\"\n        try:\n            interfaces = {}\n            for interface, addrs in psutil.net_if_addrs().items():\n                interface_info = []\n                for addr in addrs:\n                    interface_info.append({\n                        'family': str(addr.family),\n                        'address': addr.address,\n                        'netmask': addr.netmask,\n                        'broadcast': addr.broadcast\n                    })\n                interfaces[interface] = interface_info\n            \n            return {\n                'interfaces': interfaces,\n                'stats': dict(psutil.net_io_counters()._asdict())\n            }\n            \n        except Exception as e:\n            logger.error(f\"Failed to get network info: {e}\")\n            return {}\n    \n    # System Settings\n    async def set_volume(self, level: int) -> bool:\n        \"\"\"Set system volume (0-100)\"\"\"\n        try:\n            logger.info(f\"Setting volume to {level}%\")\n            \n            if self.platform == \"Windows\":\n                # Use nircmd or other Windows volume control\n                success, _, _ = await self.execute_command(f\"nircmd.exe setsysvolume {int(level * 655.35)}\")\n                return success\n            elif self.platform == \"Darwin\":\n                success, _, _ = await self.execute_command(f\"osascript -e 'set volume output volume {level}'\")\n                return success\n            else:  # Linux\n                success, _, _ = await self.execute_command(f\"amixer set Master {level}%\")\n                return success\n            \n        except Exception as e:\n            logger.error(f\"Failed to set volume: {e}\")\n            return False\n    \n    async def toggle_bluetooth(self) -> bool:\n        \"\"\"Toggle Bluetooth on/off\"\"\"\n        try:\n            logger.info(\"Toggling Bluetooth\")\n            \n            if self.platform == \"Windows\":\n                # Use PowerShell to toggle Bluetooth\n                cmd = \"Add-Type -AssemblyName System.Runtime.WindowsRuntime; $asTaskGeneric = ([System.WindowsRuntimeSystemExtensions].GetMethods() | ? { $_.Name -eq 'AsTask' -and $_.GetParameters().Count -eq 1 -and $_.GetParameters()[0].ParameterType.Name -eq 'IAsyncOperation`1' })[0]; Function Await($WinRtTask, $ResultType) { $asTask = $asTaskGeneric.MakeGenericMethod($ResultType); $netTask = $asTask.Invoke($null, @($WinRtTask)); $netTask.Wait(-1) | Out-Null; $netTask.Result }; [Windows.Devices.Radios.Radio,Windows.System.Devices,ContentType=WindowsRuntime] | Out-Null; [Windows.Devices.Radios.RadioAccessStatus,Windows.System.Devices,ContentType=WindowsRuntime] | Out-Null; Await ([Windows.Devices.Radios.Radio]::RequestAccessAsync()) ([Windows.Devices.Radios.RadioAccessStatus]); $radios = Await ([Windows.Devices.Radios.Radio]::GetRadiosAsync()) ([System.Collections.Generic.IReadOnlyList[Windows.Devices.Radios.Radio]]); $bluetooth = $radios | ? { $_.Kind -eq 'Bluetooth' }; [Windows.Devices.Radios.RadioState,Windows.System.Devices,ContentType=WindowsRuntime] | Out-Null; Await ($bluetooth.SetStateAsync('On')) ([Windows.Devices.Radios.RadioAccessStatus])\"\n                success, _, _ = await self.execute_command(f\"powershell -Command \\\"{cmd}\\\"\")\n                return success\n            elif self.platform == \"Darwin\":\n                success, _, _ = await self.execute_command(\"blueutil -p toggle\")\n                return success\n            else:  # Linux\n                success, _, _ = await self.execute_command(\"bluetoothctl power toggle\")\n                return success\n            \n        except Exception as e:\n            logger.error(f\"Failed to toggle Bluetooth: {e}\")\n            return False\n    \n    # Utility Methods\n    def enable_automation(self):\n        \"\"\"Enable automation features\"\"\"\n        self.automation_enabled = True\n        logger.info(\"Automation enabled\")\n    \n    def disable_automation(self):\n        \"\"\"Disable automation features for safety\"\"\"\n        self.automation_enabled = False\n        logger.info(\"Automation disabled\")\n    \n    def take_screenshot(self, save_path: Optional[str] = None) -> Optional[str]:\n        \"\"\"Take a screenshot and optionally save it\"\"\"\n        try:\n            screenshot = pyautogui.screenshot()\n            \n            if save_path:\n                screenshot.save(save_path)\n                logger.info(f\"Screenshot saved to {save_path}\")\n                return save_path\n            else:\n                # Save to temp file\n                import tempfile\n                temp_path = tempfile.mktemp(suffix='.png')\n                screenshot.save(temp_path)\n                logger.info(f\"Screenshot saved to {temp_path}\")\n                return temp_path\n            \n        except Exception as e:\n            logger.error(f\"Failed to take screenshot: {e}\")\n            return None\n    \n    def stop(self):\n        \"\"\"Stop the system controller and cleanup\"\"\"\n        logger.info(\"Stopping system controller...\")\n        \n        # Terminate any running processes we started\n        for app_name, process in self.running_processes.items():\n            try:\n                process.terminate()\n                logger.info(f\"Terminated {app_name}\")\n            except:\n                pass\n        \n        self.running_processes.clear()\n        logger.info(\"System controller stopped\")\n\n\n# Example usage and testing\nif __name__ == \"__main__\":\n    import sys\n    sys.path.append('..')\n    from config.settings import Config\n    \n    async def test_system_controller():\n        \"\"\"Test the system controller\"\"\"\n        config = Config()\n        controller = SystemController(config)\n        \n        # Test system info\n        print(\"=== System Information ===")\n        info = controller.get_system_info()\n        print(f\"Platform: {info.get('platform')}\")\n        print(f\"CPU Count: {info.get('cpu_count')}\")\n        print(f\"Memory: {info.get('memory', {}).get('percent')}% used\")\n        \n        # Test running applications\n        print(\"\\n=== Running Applications ===")\n        apps = controller.get_running_applications()[:5]  # Top 5\n        for app in apps:\n            print(f\"{app['name']}: {app['memory_mb']:.1f}MB\")\n        \n        # Test active window\n        print(\"\\n=== Active Window ===")\n        active = controller.get_active_window()\n        if active:\n            print(f\"Title: {active.get('title')}\")\n        \n        # Test file operations\n        print(\"\\n=== File Operations ===")\n        test_file = \"test_file.txt\"\n        if await controller.create_file(test_file, \"Hello from Desktop AI Assistant!\"):\n            print(f\"Created {test_file}\")\n            \n            if await controller.open_file(test_file):\n                print(f\"Opened {test_file}\")\n            \n            # Clean up\n            await controller.delete_file(test_file)\n            print(f\"Deleted {test_file}\")\n        \n        # Test command execution\n        print(\"\\n=== Command Execution ===")\n        if controller.platform == \"Windows\":\n            success, output, error = await controller.execute_command(\"echo Hello World\")\n        else:\n            success, output, error = await controller.execute_command(\"echo 'Hello World'\")\n        \n        if success:\n            print(f\"Command output: {output.strip()}\")\n        \n        print(\"\\nSystem controller test completed!\")\n    \n    # Run the test\n    asyncio.run(test_system_controller())\n"