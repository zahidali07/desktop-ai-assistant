"#!/usr/bin/env python3\n\"\"\"\nSensor Manager Module for Desktop AI Assistant\n\nThis module provides comprehensive sensor monitoring and data collection\nfor context awareness including system sensors, location data, battery status,\nnetwork connectivity, and environmental monitoring.\n\nFeatures:\n- Battery level monitoring\n- Network connectivity status\n- System resource monitoring\n- Location services (if available)\n- Time and calendar awareness\n- User activity detection\n- Environmental sensors (if available)\n- Real-time sensor data streaming\n\nAuthor: Desktop AI Assistant Project\nVersion: 1.0.0\n\"\"\"\n\nimport asyncio\nimport logging\nimport platform\nimport time\nimport threading\nfrom datetime import datetime, timezone\nfrom typing import Dict, List, Optional, Any, Callable\nfrom dataclasses import dataclass, asdict\nfrom enum import Enum\nimport json\n\ntry:\n    import psutil\nexcept ImportError as e:\n    logging.error(f\"Required system monitoring library not installed: {e}\")\n    logging.error(\"Please install: pip install psutil\")\n\n# Platform-specific imports for additional sensors\nif platform.system() == \"Windows\":\n    try:\n        import wmi\n    except ImportError:\n        logging.warning(\"Windows WMI library not available. Install: pip install WMI\")\nelif platform.system() == \"Darwin\":\n    try:\n        import CoreLocation\n        import CoreMotion\n    except ImportError:\n        logging.warning(\"macOS Core libraries not available. Install: pip install pyobjc\")\nelif platform.system() == \"Linux\":\n    try:\n        import dbus\n    except ImportError:\n        logging.warning(\"Linux D-Bus library not available. Install: pip install dbus-python\")\n\nlogger = logging.getLogger(__name__)\n\n\nclass SensorType(Enum):\n    \"\"\"Types of sensors available\"\"\"\n    BATTERY = \"battery\"\n    NETWORK = \"network\"\n    SYSTEM = \"system\"\n    LOCATION = \"location\"\n    TIME = \"time\"\n    USER_ACTIVITY = \"user_activity\"\n    ENVIRONMENT = \"environment\"\n\n\n@dataclass\nclass SensorReading:\n    \"\"\"Individual sensor reading\"\"\"\n    sensor_type: SensorType\n    timestamp: float\n    value: Any\n    unit: Optional[str] = None\n    metadata: Optional[Dict[str, Any]] = None\n\n\n@dataclass\nclass BatteryStatus:\n    \"\"\"Battery status information\"\"\"\n    percentage: float\n    is_charging: bool\n    time_remaining: Optional[int]  # seconds\n    power_source: str\n\n\n@dataclass\nclass NetworkStatus:\n    \"\"\"Network connectivity status\"\"\"\n    is_connected: bool\n    connection_type: str  # wifi, ethernet, cellular, etc.\n    signal_strength: Optional[float]\n    ip_address: Optional[str]\n    network_name: Optional[str]\n\n\n@dataclass\nclass SystemStatus:\n    \"\"\"System resource status\"\"\"\n    cpu_percent: float\n    memory_percent: float\n    disk_percent: float\n    temperature: Optional[float]\n    uptime: float\n\n\n@dataclass\nclass LocationData:\n    \"\"\"Location information\"\"\"\n    latitude: Optional[float]\n    longitude: Optional[float]\n    altitude: Optional[float]\n    accuracy: Optional[float]\n    address: Optional[str]\n\n\n@dataclass\nclass TimeContext:\n    \"\"\"Time and calendar context\"\"\"\n    current_time: datetime\n    timezone: str\n    day_of_week: str\n    is_weekend: bool\n    is_business_hours: bool\n\n\n@dataclass\nclass UserActivity:\n    \"\"\"User activity information\"\"\"\n    is_active: bool\n    idle_time: float  # seconds\n    active_window: Optional[str]\n    keyboard_activity: bool\n    mouse_activity: bool\n\n\nclass SensorManager:\n    \"\"\"\n    Comprehensive sensor monitoring and data collection manager\n    \"\"\"\n    \n    def __init__(self, config):\n        self.config = config\n        self.platform = platform.system()\n        self.is_monitoring = False\n        self.sensor_data = {}\n        self.callbacks = {}\n        self.monitoring_thread = None\n        self.update_interval = getattr(config, 'SENSOR_UPDATE_INTERVAL', 5.0)  # seconds\n        \n        # Initialize platform-specific components\n        self._initialize_platform_sensors()\n        \n        logger.info(f\"Sensor manager initialized for {self.platform}\")\n    \n    def _initialize_platform_sensors(self):\n        \"\"\"Initialize platform-specific sensor capabilities\"\"\"\n        if self.platform == \"Windows\":\n            self._init_windows_sensors()\n        elif self.platform == \"Darwin\":\n            self._init_macos_sensors()\n        elif self.platform == \"Linux\":\n            self._init_linux_sensors()\n    \n    def _init_windows_sensors(self):\n        \"\"\"Initialize Windows-specific sensors\"\"\"\n        try:\n            self.wmi_available = True\n            logger.info(\"Windows WMI sensors available\")\n        except:\n            self.wmi_available = False\n            logger.warning(\"Windows WMI sensors not available\")\n    \n    def _init_macos_sensors(self):\n        \"\"\"Initialize macOS-specific sensors\"\"\"\n        try:\n            self.core_location_available = True\n            logger.info(\"macOS Core Location sensors available\")\n        except:\n            self.core_location_available = False\n            logger.warning(\"macOS Core Location sensors not available\")\n    \n    def _init_linux_sensors(self):\n        \"\"\"Initialize Linux-specific sensors\"\"\"\n        try:\n            self.dbus_available = True\n            logger.info(\"Linux D-Bus sensors available\")\n        except:\n            self.dbus_available = False\n            logger.warning(\"Linux D-Bus sensors not available\")\n    \n    # Battery Monitoring\n    def get_battery_status(self) -> Optional[BatteryStatus]:\n        \"\"\"Get current battery status\"\"\"\n        try:\n            if not hasattr(psutil, 'sensors_battery'):\n                return None\n            \n            battery = psutil.sensors_battery()\n            if battery is None:\n                return None\n            \n            return BatteryStatus(\n                percentage=battery.percent,\n                is_charging=battery.power_plugged,\n                time_remaining=battery.secsleft if battery.secsleft != psutil.POWER_TIME_UNLIMITED else None,\n                power_source=\"AC\" if battery.power_plugged else \"Battery\"\n            )\n            \n        except Exception as e:\n            logger.error(f\"Failed to get battery status: {e}\")\n            return None\n    \n    # Network Monitoring\n    def get_network_status(self) -> NetworkStatus:\n        \"\"\"Get current network connectivity status\"\"\"\n        try:\n            # Check internet connectivity\n            import socket\n            try:\n                socket.create_connection((\"8.8.8.8\", 53), timeout=3)\n                is_connected = True\n            except OSError:\n                is_connected = False\n            \n            # Get network interfaces\n            interfaces = psutil.net_if_addrs()\n            active_interface = None\n            ip_address = None\n            \n            for interface_name, addresses in interfaces.items():\n                if interface_name.startswith(('eth', 'wlan', 'en', 'wl')):\n                    for addr in addresses:\n                        if addr.family == socket.AF_INET and not addr.address.startswith('127.'):\n                            active_interface = interface_name\n                            ip_address = addr.address\n                            break\n            \n            # Determine connection type\n            connection_type = \"unknown\"\n            if active_interface:\n                if 'eth' in active_interface or 'en' in active_interface:\n                    connection_type = \"ethernet\"\n                elif 'wlan' in active_interface or 'wl' in active_interface:\n                    connection_type = \"wifi\"\n            \n            return NetworkStatus(\n                is_connected=is_connected,\n                connection_type=connection_type,\n                signal_strength=None,  # Would need platform-specific implementation\n                ip_address=ip_address,\n                network_name=active_interface\n            )\n            \n        except Exception as e:\n            logger.error(f\"Failed to get network status: {e}\")\n            return NetworkStatus(\n                is_connected=False,\n                connection_type=\"unknown\",\n                signal_strength=None,\n                ip_address=None,\n                network_name=None\n            )\n    \n    # System Monitoring\n    def get_system_status(self) -> SystemStatus:\n        \"\"\"Get current system resource status\"\"\"\n        try:\n            cpu_percent = psutil.cpu_percent(interval=1)\n            memory = psutil.virtual_memory()\n            disk = psutil.disk_usage('/')\n            \n            # Get system temperature (if available)\n            temperature = None\n            try:\n                if hasattr(psutil, 'sensors_temperatures'):\n                    temps = psutil.sensors_temperatures()\n                    if temps:\n                        # Get first available temperature reading\n                        for sensor_name, sensor_list in temps.items():\n                            if sensor_list:\n                                temperature = sensor_list[0].current\n                                break\n            except:\n                pass\n            \n            # Get system uptime\n            uptime = time.time() - psutil.boot_time()\n            \n            return SystemStatus(\n                cpu_percent=cpu_percent,\n                memory_percent=memory.percent,\n                disk_percent=disk.percent,\n                temperature=temperature,\n                uptime=uptime\n            )\n            \n        except Exception as e:\n            logger.error(f\"Failed to get system status: {e}\")\n            return SystemStatus(\n                cpu_percent=0.0,\n                memory_percent=0.0,\n                disk_percent=0.0,\n                temperature=None,\n                uptime=0.0\n            )\n    \n    # Location Services\n    def get_location_data(self) -> Optional[LocationData]:\n        \"\"\"Get current location data (if available and permitted)\"\"\"\n        try:\n            # This would require platform-specific implementation\n            # and user permission for location access\n            \n            if self.platform == \"Darwin\" and hasattr(self, 'core_location_available'):\n                # macOS Core Location implementation would go here\n                pass\n            elif self.platform == \"Windows\":\n                # Windows Location API implementation would go here\n                pass\n            elif self.platform == \"Linux\":\n                # Linux GeoClue implementation would go here\n                pass\n            \n            # For now, return None as location requires special permissions\n            return None\n            \n        except Exception as e:\n            logger.error(f\"Failed to get location data: {e}\")\n            return None\n    \n    # Time and Calendar Context\n    def get_time_context(self) -> TimeContext:\n        \"\"\"Get current time and calendar context\"\"\"\n        try:\n            now = datetime.now(timezone.utc)\n            local_now = now.astimezone()\n            \n            day_of_week = local_now.strftime('%A')\n            is_weekend = local_now.weekday() >= 5  # Saturday = 5, Sunday = 6\n            \n            # Define business hours (9 AM to 5 PM)\n            hour = local_now.hour\n            is_business_hours = 9 <= hour < 17 and not is_weekend\n            \n            return TimeContext(\n                current_time=local_now,\n                timezone=str(local_now.tzinfo),\n                day_of_week=day_of_week,\n                is_weekend=is_weekend,\n                is_business_hours=is_business_hours\n            )\n            \n        except Exception as e:\n            logger.error(f\"Failed to get time context: {e}\")\n            return TimeContext(\n                current_time=datetime.now(),\n                timezone=\"UTC\",\n                day_of_week=\"Unknown\",\n                is_weekend=False,\n                is_business_hours=False\n            )\n    \n    # User Activity Monitoring\n    def get_user_activity(self) -> UserActivity:\n        \"\"\"Get current user activity status\"\"\"\n        try:\n            # Get idle time (platform-specific)\n            idle_time = self._get_idle_time()\n            is_active = idle_time < 60  # Consider active if idle < 1 minute\n            \n            # Get active window (would need system controller integration)\n            active_window = None\n            \n            # Detect recent keyboard/mouse activity\n            keyboard_activity = idle_time < 5\n            mouse_activity = idle_time < 5\n            \n            return UserActivity(\n                is_active=is_active,\n                idle_time=idle_time,\n                active_window=active_window,\n                keyboard_activity=keyboard_activity,\n                mouse_activity=mouse_activity\n            )\n            \n        except Exception as e:\n            logger.error(f\"Failed to get user activity: {e}\")\n            return UserActivity(\n                is_active=True,\n                idle_time=0.0,\n                active_window=None,\n                keyboard_activity=False,\n                mouse_activity=False\n            )\n    \n    def _get_idle_time(self) -> float:\n        \"\"\"Get system idle time in seconds\"\"\"\n        try:\n            if self.platform == \"Windows\":\n                import ctypes\n                from ctypes import wintypes\n                \n                class LASTINPUTINFO(ctypes.Structure):\n                    _fields_ = [('cbSize', wintypes.UINT), ('dwTime', wintypes.DWORD)]\n                \n                lii = LASTINPUTINFO()\n                lii.cbSize = ctypes.sizeof(LASTINPUTINFO)\n                ctypes.windll.user32.GetLastInputInfo(ctypes.byref(lii))\n                \n                millis = ctypes.windll.kernel32.GetTickCount() - lii.dwTime\n                return millis / 1000.0\n                \n            elif self.platform == \"Darwin\":\n                import subprocess\n                result = subprocess.run(['ioreg', '-c', 'IOHIDSystem'], \n                                      capture_output=True, text=True)\n                for line in result.stdout.split('\\n'):\n                    if 'HIDIdleTime' in line:\n                        idle_ns = int(line.split('=')[1].strip())\n                        return idle_ns / 1000000000.0\n                return 0.0\n                \n            elif self.platform == \"Linux\":\n                import subprocess\n                try:\n                    result = subprocess.run(['xprintidle'], capture_output=True, text=True)\n                    return float(result.stdout.strip()) / 1000.0\n                except:\n                    return 0.0\n            \n            return 0.0\n            \n        except Exception as e:\n            logger.error(f\"Failed to get idle time: {e}\")\n            return 0.0\n    \n    # Sensor Data Collection\n    def collect_all_sensor_data(self) -> Dict[str, Any]:\n        \"\"\"Collect data from all available sensors\"\"\"\n        sensor_data = {}\n        timestamp = time.time()\n        \n        try:\n            # Battery status\n            battery = self.get_battery_status()\n            if battery:\n                sensor_data['battery'] = asdict(battery)\n            \n            # Network status\n            network = self.get_network_status()\n            sensor_data['network'] = asdict(network)\n            \n            # System status\n            system = self.get_system_status()\n            sensor_data['system'] = asdict(system)\n            \n            # Time context\n            time_context = self.get_time_context()\n            sensor_data['time'] = asdict(time_context)\n            # Convert datetime to string for JSON serialization\n            sensor_data['time']['current_time'] = time_context.current_time.isoformat()\n            \n            # User activity\n            user_activity = self.get_user_activity()\n            sensor_data['user_activity'] = asdict(user_activity)\n            \n            # Location (if available)\n            location = self.get_location_data()\n            if location:\n                sensor_data['location'] = asdict(location)\n            \n            # Add metadata\n            sensor_data['timestamp'] = timestamp\n            sensor_data['platform'] = self.platform\n            \n            return sensor_data\n            \n        except Exception as e:\n            logger.error(f\"Failed to collect sensor data: {e}\")\n            return {'timestamp': timestamp, 'error': str(e)}\n    \n    # Monitoring and Callbacks\n    def start_monitoring(self):\n        \"\"\"Start continuous sensor monitoring\"\"\"\n        if self.is_monitoring:\n            logger.warning(\"Sensor monitoring already started\")\n            return\n        \n        self.is_monitoring = True\n        self.monitoring_thread = threading.Thread(target=self._monitoring_loop, daemon=True)\n        self.monitoring_thread.start()\n        logger.info(\"Sensor monitoring started\")\n    \n    def stop_monitoring(self):\n        \"\"\"Stop sensor monitoring\"\"\"\n        self.is_monitoring = False\n        if self.monitoring_thread:\n            self.monitoring_thread.join(timeout=5)\n        logger.info(\"Sensor monitoring stopped\")\n    \n    def _monitoring_loop(self):\n        \"\"\"Main monitoring loop\"\"\"\n        while self.is_monitoring:\n            try:\n                # Collect sensor data\n                data = self.collect_all_sensor_data()\n                self.sensor_data = data\n                \n                # Trigger callbacks\n                for sensor_type, callback in self.callbacks.items():\n                    try:\n                        if sensor_type == 'all' or sensor_type in data:\n                            callback(data)\n                    except Exception as e:\n                        logger.error(f\"Error in sensor callback for {sensor_type}: {e}\")\n                \n                # Wait for next update\n                time.sleep(self.update_interval)\n                \n            except Exception as e:\n                logger.error(f\"Error in monitoring loop: {e}\")\n                time.sleep(self.update_interval)\n    \n    def register_callback(self, sensor_type: str, callback: Callable[[Dict[str, Any]], None]):\n        \"\"\"Register a callback for sensor data updates\"\"\"\n        self.callbacks[sensor_type] = callback\n        logger.info(f\"Registered callback for {sensor_type} sensor data\")\n    \n    def unregister_callback(self, sensor_type: str):\n        \"\"\"Unregister a sensor callback\"\"\"\n        if sensor_type in self.callbacks:\n            del self.callbacks[sensor_type]\n            logger.info(f\"Unregistered callback for {sensor_type} sensor data\")\n    \n    # Data Access\n    def get_latest_sensor_data(self) -> Dict[str, Any]:\n        \"\"\"Get the latest collected sensor data\"\"\"\n        return self.sensor_data.copy()\n    \n    def get_sensor_reading(self, sensor_type: SensorType) -> Optional[SensorReading]:\n        \"\"\"Get a specific sensor reading\"\"\"\n        try:\n            data = self.collect_all_sensor_data()\n            sensor_key = sensor_type.value\n            \n            if sensor_key in data:\n                return SensorReading(\n                    sensor_type=sensor_type,\n                    timestamp=data['timestamp'],\n                    value=data[sensor_key],\n                    metadata={'platform': self.platform}\n                )\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Failed to get sensor reading for {sensor_type}: {e}\")\n            return None\n    \n    # Context Analysis\n    def analyze_context(self) -> Dict[str, Any]:\n        \"\"\"Analyze current context based on sensor data\"\"\"\n        try:\n            data = self.get_latest_sensor_data()\n            context = {}\n            \n            # Battery context\n            if 'battery' in data:\n                battery = data['battery']\n                if battery['percentage'] < 20:\n                    context['battery_warning'] = \"Low battery\"\n                elif battery['percentage'] < 50 and not battery['is_charging']:\n                    context['battery_notice'] = \"Battery getting low\"\n            \n            # Network context\n            if 'network' in data:\n                network = data['network']\n                if not network['is_connected']:\n                    context['connectivity_issue'] = \"No internet connection\"\n            \n            # System performance context\n            if 'system' in data:\n                system = data['system']\n                if system['cpu_percent'] > 80:\n                    context['performance_warning'] = \"High CPU usage\"\n                if system['memory_percent'] > 85:\n                    context['memory_warning'] = \"High memory usage\"\n            \n            # Time context\n            if 'time' in data:\n                time_data = data['time']\n                if time_data['is_weekend']:\n                    context['time_context'] = \"Weekend\"\n                elif time_data['is_business_hours']:\n                    context['time_context'] = \"Business hours\"\n                else:\n                    context['time_context'] = \"After hours\"\n            \n            # User activity context\n            if 'user_activity' in data:\n                activity = data['user_activity']\n                if not activity['is_active']:\n                    context['user_status'] = \"Idle\"\n                elif activity['idle_time'] > 300:  # 5 minutes\n                    context['user_status'] = \"Away\"\n                else:\n                    context['user_status'] = \"Active\"\n            \n            return context\n            \n        except Exception as e:\n            logger.error(f\"Failed to analyze context: {e}\")\n            return {}\n    \n    # Utility Methods\n    def get_sensor_summary(self) -> str:\n        \"\"\"Get a human-readable summary of current sensor status\"\"\"\n        try:\n            data = self.get_latest_sensor_data()\n            summary_parts = []\n            \n            if 'battery' in data:\n                battery = data['battery']\n                status = \"charging\" if battery['is_charging'] else \"on battery\"\n                summary_parts.append(f\"Battery: {battery['percentage']:.0f}% ({status})\")\n            \n            if 'network' in data:\n                network = data['network']\n                conn_status = \"connected\" if network['is_connected'] else \"disconnected\"\n                summary_parts.append(f\"Network: {conn_status} via {network['connection_type']}\")\n            \n            if 'system' in data:\n                system = data['system']\n                summary_parts.append(f\"CPU: {system['cpu_percent']:.0f}%, Memory: {system['memory_percent']:.0f}%\")\n            \n            if 'time' in data:\n                time_data = data['time']\n                summary_parts.append(f\"Time: {time_data['day_of_week']}, {time_data['time_context']}\")\n            \n            return \"; \".join(summary_parts) if summary_parts else \"No sensor data available\"\n            \n        except Exception as e:\n            logger.error(f\"Failed to generate sensor summary: {e}\")\n            return \"Error generating sensor summary\"\n    \n    def export_sensor_data(self, format: str = 'json') -> str:\n        \"\"\"Export current sensor data in specified format\"\"\"\n        try:\n            data = self.get_latest_sensor_data()\n            \n            if format.lower() == 'json':\n                return json.dumps(data, indent=2, default=str)\n            else:\n                return str(data)\n                \n        except Exception as e:\n            logger.error(f\"Failed to export sensor data: {e}\")\n            return \"{}\"\n    \n    def stop(self):\n        \"\"\"Stop the sensor manager and cleanup\"\"\"\n        logger.info(\"Stopping sensor manager...\")\n        self.stop_monitoring()\n        self.callbacks.clear()\n        logger.info(\"Sensor manager stopped\")\n\n\n# Example usage and testing\nif __name__ == \"__main__\":\n    import sys\n    sys.path.append('..')\n    from config.settings import Config\n    \n    def test_sensor_manager():\n        \"\"\"Test the sensor manager\"\"\"\n        config = Config()\n        sensor_manager = SensorManager(config)\n        \n        print(\"=== Sensor Manager Test ===")\n        \n        # Test individual sensors\n        print(\"\\n--- Battery Status ---\")\n        battery = sensor_manager.get_battery_status()\n        if battery:\n            print(f\"Battery: {battery.percentage}% ({'charging' if battery.is_charging else 'on battery'})\")\n        else:\n            print(\"Battery information not available\")\n        \n        print(\"\\n--- Network Status ---\")\n        network = sensor_manager.get_network_status()\n        print(f\"Network: {'connected' if network.is_connected else 'disconnected'} via {network.connection_type}\")\n        if network.ip_address:\n            print(f\"IP Address: {network.ip_address}\")\n        \n        print(\"\\n--- System Status ---\")\n        system = sensor_manager.get_system_status()\n        print(f\"CPU: {system.cpu_percent}%, Memory: {system.memory_percent}%, Disk: {system.disk_percent}%\")\n        if system.temperature:\n            print(f\"Temperature: {system.temperature}°C\")\n        \n        print(\"\\n--- Time Context ---\")\n        time_context = sensor_manager.get_time_context()\n        print(f\"Time: {time_context.current_time.strftime('%Y-%m-%d %H:%M:%S')}\")\n        print(f\"Day: {time_context.day_of_week} ({'Weekend' if time_context.is_weekend else 'Weekday'})\")\n        print(f\"Business Hours: {'Yes' if time_context.is_business_hours else 'No'}\")\n        \n        print(\"\\n--- User Activity ---\")\n        activity = sensor_manager.get_user_activity()\n        print(f\"User: {'Active' if activity.is_active else 'Idle'} (idle for {activity.idle_time:.1f}s)\")\n        \n        # Test comprehensive data collection\n        print(\"\\n--- All Sensor Data ---\")\n        all_data = sensor_manager.collect_all_sensor_data()\n        print(f\"Collected data from {len(all_data)} sensor categories\")\n        \n        # Test context analysis\n        print(\"\\n--- Context Analysis ---\")\n        context = sensor_manager.analyze_context()\n        for key, value in context.items():\n            print(f\"{key}: {value}\")\n        \n        # Test sensor summary\n        print(\"\\n--- Sensor Summary ---\")\n        summary = sensor_manager.get_sensor_summary()\n        print(summary)\n        \n        print(\"\\nSensor manager test completed!\")\n    \n    # Run the test\n    test_sensor_manager()\n"